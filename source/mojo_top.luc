//<====Global Variables====>
//1) all functions are listed here with the corresponding 5bit value.
//2) The most significant bit is used to indicated whether ALUFN signals are "ON" or "OFF"
global Func{
  const ADD   = 3b001;      // a + b
  const NOR   = 3b010;      // Returns NOR logic
  const XOR   = 3b011;      // Returns XOR logic
  const CMPEQ = 3b100;      // a == b
  const LDR   = 3b101;      // Loads
  const MUL   = 3b110;      // a *  b
  const OVFL  = 3b111;      //checks overflow. If true returns 1, else 0.
  
}



module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer fu    output io_led [3][8],   // LEDs on IO Shield
    
    
    //Game Inputs and Outputs
    input toggleD[2],
    output ledD[2],
    
    input user_input[16],
    output user_input_led[16],
    input toggleAB,
    input enter_btn,
    output stage[4],
    output right_led,
    output wrong_led,
    output timer_led[10]
    
  ) {
  
  sig rst;                  // reset signal
  sig value[16];            // current value of a or b
  var on;
  var off;
  
  var true;
  var false;
  
  eternite_alufunctions combine;    //Instantiates the game alu functions module
  
  
  dff a[16](.clk(clk), .rst(rst));        //Stores A value
  dff b[16](.clk(clk), .rst(rst));        //Stores B value
  
  dff count[28](.clk(clk), .rst(rst));    //Timer
  
  fsm diff_lvls (.clk(clk), .rst(rst)) = {SELECT_DIFFICULTY,
    E1, E2, E3, E4,
    M1, M2, M3, M4,
    H1, H2, H3, H4,
    TIMEOUT, GAME_CLEARED};
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    
    stage = 0;
    right_led = 0;
    wrong_led = 0;
    timer_led = 0;
    
    user_input_led = 0;
    value[15:0] = user_input[15:0];  //sets value by io_dip switches
    
    
    on = 8hff;              //to switch on all leds at once
    off = 8h00;             //to switch off all leds at once
    
    ledD = toggleD;         //connects diff
    
    true = 1;
    false = 0;
    
    
    combine.a = a.q;        //connects combine a to stored a value
    combine.b = b.q;        //connects combine b to stored b value
    combine.alufn = 0;  //connects combine alufn to io_dip switches
    
    user_input_led = user_input;
    
    
    
    //Storing A value
    if (toggleAB == 0  && (diff_lvls.q != diff_lvls.SELECT_DIFFICULTY) ){
      a.d = value;
      user_input_led = a.q[15:0];
      
    }
    //Storing B Value
    else if (toggleAB == 1  && (diff_lvls.q != diff_lvls.SELECT_DIFFICULTY)){
      b.d = value;
      user_input_led = b.q[15:0];
      
    }
    
    count.d = count.q + 1;          //keeps timer counting
    
    //<=================================>
    //<=========Eternite FSM============>
    //<=================================>
    case(diff_lvls.q){
      diff_lvls.SELECT_DIFFICULTY: //timer full
        right_led = on;
        wrong_led = on;
        stage[3:0] = 4b1111;
        //user_input_led = user_input; //players can toggle around in IDLE
        
        if(enter_btn == 1){
          if (toggleD == 2b10){
            diff_lvls.d = diff_lvls.E1;}
          
          else if (toggleD == 2b01){
            diff_lvls.d = diff_lvls.M1;}
          
          else if (toggleD == 2b11){
            diff_lvls.d = diff_lvls.H1;}
        }
      
      //<==========GAME CLEARED/FAILED================>
      diff_lvls.TIMEOUT:
        wrong_led = on;
        user_input_led = 16h0000;
        
        if(count.q[26] == 1){
          count.d=0;
          diff_lvls.d = diff_lvls.SELECT_DIFFICULTY;
        }
      
      
      
      
      diff_lvls.GAME_CLEARED:  //timer goes back to full
        //timer resets
        stage[3:0] = 4b1111;
        timer_led[9:0] = 10b1111111111;
        user_input_led = 16hFFFF;
        ledD = 2b11;
        
        if(count.q[26] == 1){
          count.d = 0;
          diff_lvls.d = diff_lvls.SELECT_DIFFICULTY;
        }
      
      
      //<============EASY STATES==============>
      diff_lvls.E1: //Love Poem: A=1001
        stage = 4b0001;
        combine.alufn = Func.LDR;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          
          if(combine.out == 4b1001){
            diff_lvls.d = diff_lvls.E2;
          }else{
          
          }
          
        }
      
      diff_lvls.E2: //Wedding Vow: A=0110
        stage = 4b0010;
        combine.alufn = Func.LDR;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          
          if(combine.out == 4b0110){
            diff_lvls.d = diff_lvls.E3;}
          
        }
      diff_lvls.E3: //Committed Sins: A=1011
        stage = 4b0100;
        combine.alufn = Func.LDR;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          
          
          if(combine.out == 4b1011 ){
            diff_lvls.d = diff_lvls.E4;}
          
        }
      diff_lvls.E4: //Nor_Love: ~(A|B) = 1111
        stage = 4b1000;
        combine.alufn = Func.NOR;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          
          if((combine.out[3:0] == 4b1111)){
            diff_lvls.d = diff_lvls.GAME_CLEARED;}
        }
      
      
      //<==========MEDIUM STATES===============>
      diff_lvls.M1: //Her Wishes: A == B
        stage = 4b0001;
        combine.alufn = Func.CMPEQ;
        combine.a = a.q[7:4];
        combine.b = b.q[7:4];
        
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          
          //!!!!!!!!!MUST TEST!!!!!!!!!!!!!!!!!!
          if(a.q[3:0] == 4b1001){
            if( (combine.out[0] == 1) && (a.q[3:0] == 4b1001)){
              diff_lvls.d = diff_lvls.M2;
            }
          }
        }
      
      diff_lvls.M2: //Her Diary: A=1101, answer from easy = 0110
        stage = 4b0010;
        combine.alufn = Func.LDR;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          if(combine.out == 8b11010110){
            diff_lvls.d = diff_lvls.M3;}
        }
      diff_lvls.M3: //Her Soliloquy: A=1101(14th) & B=0011(March), answer from easy 1011
        stage = 4b0100;
        
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          if(a.q == 8b11011011 && b.q == 8b00111011 ){
            diff_lvls.d = diff_lvls.M4;}
        }
      diff_lvls.M4: //Futile Endeavour: A*B=0, ignore Easy
        stage = 4b1000;
        combine.alufn = Func.MUL;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          if(combine.out == 0){
            diff_lvls.d = diff_lvls.GAME_CLEARED;}
        }
      
      
      //<===========HARD STATES================>
      diff_lvls.H1: //His Wishes: A = 0010 0010 B = 0001 1011 (221B)
        stage = 4b0001;
        
        combine.alufn = Func.CMPEQ;
        combine.a = a.q[7:4];
        combine.b = b.q[7:4];
        
        //!!!!!!!!!!!!!!!MUST TEST!!!!!!!!!!!!!!!!!
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          if( (a.q == 16b00100010XXXX1001) && (b.q == 16b00011011XXXXXXXX) && (combine.out[0] == (a.q[7:4] == b.q[7:4]))  ){
            diff_lvls.d = diff_lvls.H2;
          }
        }
      diff_lvls.H2: //XOR_Date: A^B = 0, Medium = 1101, Easy= 0110
        stage = 4b0010;
        
        combine.alufn = Func.XOR;
        combine.a = a.q[15:8];
        combine.b = b.q[15:8];
        
        //!!!!!!!!MUST TEST!!!!!!!!!!!!!
        if(count.q[24] == 1 & enter_btn == 1){
          if( (combine.out == 8hFF) && (a.q[7:0] == 8b11010110) ){
            diff_lvls.d = diff_lvls.H3;}
        }
      diff_lvls.H3: //Project Completion: A=1100 0101 B:00010001 (12/5/17), ans from medium A=1101(14th) & B=0011(March), answer from easy 1011
        stage = 4b0100;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          if( (a.q == 16b1100010111011011) && (b.q == 16b000100010011XXXX) ){ //if not working, try change && -> &
            diff_lvls.d = diff_lvls.H4;
          }
        }
      diff_lvls.H4: //Their love overflows: A + B = 1 XXXX XXXX XXXX XXXX
        stage = 4b1000;
        
        combine.alufn = Func.OVFL;
        
        if(count.q[24] == 1 & enter_btn == 1){
          count.d = 0;
          if(combine.out == 1){
            diff_lvls.d = diff_lvls.GAME_CLEARED;
          }
        }
      
      
      
      
      
      
      
    }
    
    
    
    //Reset from middle of gameplay
    if (b.q[15:0] == 16b1111111111111111 && a.q[15:0] == 16b1010101010101010 && enter_btn == 1 && toggleD == 2b00){
      count.d = 0;
      diff_lvls.d = diff_lvls.SELECT_DIFFICULTY;
    }
  }
}